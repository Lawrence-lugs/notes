<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-18">

<title>Lawrence Roman A. Quizon - Generalized Eigenvalues in FEM Formulations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Lawrence Roman A. Quizon</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Generalized Eigenvalues in FEM Formulations</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 18, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="generalized-eigenvalue-problem" class="level1">
<h1>Generalized Eigenvalue Problem</h1>
<p>The eigenvectors and eigenvalues of <span class="math inline">\(\mathbf{M}\)</span> and <span class="math inline">\(\mathbf{K}\)</span> can significantly simplify solutions of the FEM problem.</p>
<p>Decomposing the solution <span class="math inline">\(u(x,t)\)</span> into a linear combination of eigenvalues and eigenvectors allows to solve only the <span class="math inline">\(N\)</span> (like 20 or so) most important modalities. The rest of the eigenvectors contribute so little to <span class="math inline">\(u(x,t)\)</span> that numeric error outscales it, so they’re not really necessary.</p>
<p>We can look at the unforced FEM formulation of the heat equation for this: <span class="math display">\[\mathbf{M}\vec{\frac{du}{dt}}+\mathbf{K}\vec{u}=0\]</span> If we can find the eigenvector <span class="math inline">\(\vec{v}\)</span> of <span class="math inline">\(\mathbf{K}\)</span> and <span class="math inline">\(\mathbf{M}\)</span> with eigenvalue <span class="math inline">\(\lambda\)</span>, we can just do: Let <span class="math inline">\(\vec{u}=\vec{v}e^{-\lambda t}\)</span> (decay). Then, <span class="math display">\[-\mathbf{M}\lambda\vec{u}+\mathbf{K}\vec{u}=0\]</span> <span class="math display">\[-\mathbf{M}\lambda\vec{v}e^{-\lambda t}+\mathbf{K}\vec{v}e^{-\lambda t}=0\]</span> <span class="math display">\[-\mathbf{M}\lambda\vec{v}+\mathbf{K}\vec{v}=0\]</span> and we get that the <span class="math inline">\(\lambda\)</span> are the eigenvalues in a <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix#Generalized_eigenvalue_problem">generalized eigenvalue problem</a>.</p>
<p>Then, we can use this in some Fourier or Laplace magic (in this case, laplace magic because the time-varying forms called <span class="math inline">\(\xi(t)=e^{-\lambda t}\)</span> are decay forms)</p>
<p>We can project the solution into a basis of a bunch of discrete <span class="math inline">\(\lambda\)</span> time constants and add up the solutions for each of those.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="The Spectral Theorem">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Spectral Theorem
</div>
</div>
<div class="callout-body-container callout-body">
<p>In fact, the spectral theorem gives us that if <span class="math inline">\(K\)</span> and <span class="math inline">\(M\)</span> are symmetric positive-definite matrices, we can always get real <span class="math inline">\(\lambda\)</span> and that the eigenvectors <span class="math inline">\(v_1,v_2,...,v_3\)</span> form a basis. This means we can project the true solution into the basis.</p>
</div>
</div>
<p>So then, the exact solution becomes a linear combination of eigenvectors: <span class="math display">\[u(t)=\sum^{N}_{i=1} c_iv_ie^{-\lambda_it}\]</span></p>
</section>
<section id="generalized-eigenvalues-with-a-force-term" class="level1">
<h1>Generalized eigenvalues with a force term</h1>
<p>With a force term, we get something like <span class="math display">\[-\mathbf{M}\lambda\vec{v}e^{-\lambda t}+\mathbf{K}\vec{v}e^{-\lambda t}=\mathbf{F}\]</span> In this case, the time term is incorrect (the forcing term prevents it from just being a decay, making the “guess” incorrect)</p>
<p>So then, we just avoid guessing a time term completely.</p>
<p>Let <span class="math inline">\(\vec{u}=\vec{v_i}\xi_i(t)\)</span></p>
<p>Then we can use this in the FEM formulation <span class="math display">\[\mathbf{M} \left( \sum_{i=1}^N \dot{\xi}_i(t) \vec{v}_i \right) + \mathbf{K} \left( \sum_{i=1}^N \xi_i(t) \vec{v}_i \right) = \mathbf{F}(t)\]</span> To isolate the solution for a specific mode, <span class="math inline">\(v_i\)</span>, we multiply with the ket form <span class="math inline">\(v_j^T\)</span> to “precipitate out” the important terms. <span class="math display">\[\vec{v}_j^T \mathbf{M} \left( \sum \dot{\xi}_i \vec{v}_i \right) + \vec{v}_j^T \mathbf{K} \left( \sum \xi_i \vec{v}_i \right) = \vec{v}_j^T \mathbf{F}(t)\]</span> That is, important terms being <strong>only the ones with <span class="math inline">\(i=j\)</span></strong>. For the other terms, <span class="math display">\[v_j^T \mathbf{M} v_i=0 \text{ if }i \neq j \text{ (orthogonal basis)}\]</span> <span class="math display">\[v_j^T \mathbf{K} v_i=0 \text{ if }i \neq j \text{ (orthogonal basis)}\]</span> We’re left with the <span class="math inline">\(\xi_i(t)\)</span> terms mixed with a simple scalar form. <span class="math display">\[\vec{v}_j^T \mathbf{M} \vec{v}_j\dot{\xi}_j(t) + \vec{v}_j^T \mathbf{K} \vec{v}_j\xi_j(t)=\vec{v}_j^T\mathbf{F}(t)\]</span> We call these terms “modal mass, modal stiffness, and modal force”: <span class="math display">\[m_j \dot{\xi}_j(t) + k_j \xi_j(t) = f_j(t)\]</span></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Interestingly, these terms resemble the ket forms in quantum mechanics <span class="math display">\[\bra{v}\mathbf{M}\ket{v}, \bra{v}\mathbf{K}\ket{v}, \bra{v}\mathbf{F}\]</span> Apparetly <span class="math inline">\(\bra{v}\mathbf{M}\ket{v}\)</span> is called the kinetic energy norm and <span class="math inline">\(\bra{v}\mathbf{K}\ket{v}\)</span> is called the Strain Energy</p>
</div>
</div>
<p>Now we have a simply solvable calculus problem: <span class="math display">\[\frac{d\xi_j}{dt}+\lambda_j\xi_j=\frac{f_j(t)}{m_j}\]</span> whose solution is <span class="math display">\[\xi_j(t)=\xi_j(0)e^{-\lambda_j t}+\int_0^td\tau e^{-\lambda_j (t-\tau)} \frac{f_j(\tau)}{m_j}\]</span></p>
<p>The thing is, we have to do that for <em>every single modality we’re accounting for</em>.</p>
<p>Maybe the good news is that solving for the <span class="math inline">\(\xi_j\)</span> form once probably makes it trivial to get all the others (<span class="math inline">\(f_j\)</span> will likely rarely change in form per <span class="math inline">\(j\)</span>, more like only scaling)</p>
<div class="callout callout-style-default callout-tip callout-titled" title="For second-order FEM formulas">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
For second-order FEM formulas
</div>
</div>
<div class="callout-body-container callout-body">
<p>For things like the beam equation, for example, the solution turns out to be <span class="math display">\[\ddot{\xi} + \omega_0^2 \xi = f(t)\]</span> <span class="math display">\[\xi(t) = \int_0^t \frac{1}{\omega_0} \sin(\omega_0(t-\tau)) f(\tau) d\tau\]</span></p>
</div>
</div>
</section>
<section id="how-to-solve-a-generalized-eigenvalue-problem" class="level1">
<h1>How to solve a generalized eigenvalue problem?</h1>
<p>Starting from <span class="math display">\[-\mathbf{M}\lambda\vec{v}+\mathbf{K}\vec{v}=0\]</span> we still need to solve for the <span class="math inline">\(\lambda_j\)</span>s and the <span class="math inline">\(\vec{v_j}\)</span>s.</p>
<p>We use the Lanczos algorithm for this (kind of like Givens rotations etc. algorithms for QR decomposition.)</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This is nice because the Lanczos algorithm can give the eigenvalues in order of importants (like PCA). That’s because it usually gives it in order of highest to lowest (like most linalg iterative algorithms) but if you do shift-and-invert you can make the lowest eigenvalues the highest.</p>
</div>
</div>
</section>
<section id="where-is-this-used" class="level1">
<h1>Where is this used?</h1>
<p>Only used for problems with nice well-defined structures whose properties <span class="math inline">\(\mathbf{M}\)</span> and <span class="math inline">\(\mathbf{K}\)</span> do not change over the course of the simulation.</p>
<p>Problems where it’s applicable:</p>
<ul>
<li>Tall building (doesn’t really change behavior until it breaks)</li>
<li>PCB vibration</li>
<li>Drivetrains and gears</li>
<li>Laminar flow (apparently you just have the Stokes Equation for this)</li>
</ul>
<p>Problems where it’s inapplicable:</p>
<ul>
<li>Turbulent flow (you have to use Navier-Stokes, which has an advection <span class="math inline">\((\vec{v} \cdot \nabla) \vec{v}\)</span> term that will appear as <span class="math inline">\(\mathbf{K}(v)\)</span>. Stiffness is a function of <span class="math inline">\(v\)</span>. For these, we have to directly solve the FEM form.</li>
</ul>
</section>
<section id="notes" class="level1">
<h1>Notes</h1>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>The eigenvalues <span class="math inline">\(\lambda_i\)</span> are not like harmonics- they can be randomly spaced in between each other. <span class="math inline">\(\lambda_2\)</span> might be <span class="math inline">\(1.43 \times \lambda_1\)</span>. <span class="math inline">\(\lambda_3\)</span> might be <span class="math inline">\(2.11 \times \lambda_1\)</span>.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>In practice, we choose some “Nyquist maximum” frequency at which to stop caring about the solution. So then we solve for all <span class="math inline">\(\lambda_n &lt; 1Grads\)</span> or <span class="math inline">\(\omega_n &lt; 1Grads\)</span> if we expect the forcing function <span class="math inline">\(f\)</span>.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Cool thing:">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Cool thing:
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(\vec{v}_j^T\mathbf{F}(t)\)</span> is literally use projecting the “simulation stimulus force” onto the eigenvector basis. So then putting specific modalities of vibration or decay in <span class="math inline">\(F\)</span> would allow us to simulate resonance type things. We’re not turning <span class="math inline">\(F\)</span> into its fourier transform. Rather, we’re asking how much does <span class="math inline">\(F\)</span> looks like <span class="math inline">\(v_1\)</span>? How much does it look like <span class="math inline">\(v_2\)</span>? etc.</p>
</div>
</div>
</section>
<section id="test-coverage-and-using-eigenvalue-based-fem-correctly" class="level1">
<h1>“Test coverage” and using eigenvalue-based FEM correctly:</h1>
<div class="callout callout-style-default callout-note callout-titled" title="Effective Modal Inertia">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Effective Modal Inertia
</div>
</div>
<div class="callout-body-container callout-body">
<p>A parameter named “effective modal inertia” captures the “test coverage” of eigenvectors- capturing how much the current set of eigenvectors makes up the overall response to a stimulus <span class="math inline">\(F\)</span>.</p>
<p>Simulating with a specific <span class="math inline">\(F\)</span> like an earthquake you try to get up to 90% “test coverage” (effective modal inertia) on it.</p>
<p>Then, you think of another <span class="math inline">\(F\)</span> to test it out with. Say, supertyphoon winds, then you get 90% test coverage on that.</p>
<p>If you fail to find the <span class="math inline">\(F\)</span> that breaks your thing, that’s unfortunate.</p>
</div>
</div>
<p>I have an idea.</p>
<p>I wonder if we can design <span class="math inline">\(F\)</span> to be “constant white noise” in the “eigenvector basis” so that we can use one <span class="math inline">\(F\)</span> to simulate all behaviors?</p>
<p>This is apparently called “Response Spectrum Analysis”. Commercial simulators have this feature, as it looks like in Google results.</p>
<blockquote class="blockquote">
<p>Ok. Since we can disastrously miss resonance modes that can cause failure, let’s just go back to the direct FEM solution.</p>
</blockquote>
<p>For this one, we’re limited instead by the <span class="math inline">\(\Delta t\)</span> used in the RK4 or the reverse euler solution.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>